<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王安正的随想集</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://focinfi.wang/"/>
  <updated>2017-03-18T13:59:42.000Z</updated>
  <id>http://focinfi.wang/</id>
  
  <author>
    <name>王安正</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rails 学习感想</title>
    <link href="http://focinfi.wang/2016/07/30/rails-note-for-fe-developer/"/>
    <id>http://focinfi.wang/2016/07/30/rails-note-for-fe-developer/</id>
    <published>2016-07-30T04:23:02.000Z</published>
    <updated>2017-03-18T13:59:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>后端(应用层)不同于前端，最重要的概念是 middleware/pipeline.</p>
<p>Rails能较为深入的理解一定要建立在对后端整体架构理解架构的基础上，不然就会进入开始很爽越来越晕的尴尬节奏。</p>
<p>大致分为两大部分：Server/App，一个负责接收分发 request，一个负责业务逻辑，他们之间的数据对接靠 Rack 规范。Server 具体可参考<a href="http://insights.thoughtworkers.org/ruby-web-server/" target="_blank" rel="external">这篇文章</a>。而 App 部分就是 Rails。</p>
<a id="more"></a>
<p>Rails干的活一句话就是一个按照 Rack 标准数据格式化的 Request 进来，分析url，分配给它一个 Handler 方法处理：</p>
<ol>
<li>解析 url 参数，HTTP header/body</li>
<li>身份验证，权限验证</li>
<li>Database操作</li>
<li>渲染需要返回的数据（html/json）</li>
</ol>
<p>当然为了控制 App 的逻辑复杂度，Rails 采用 MVC 架构，遵循 convention over configuration，don’t repeat yourself 理念，尽量将 Server API 设计的 restful.</p>
<p>Rails 重要的组件都是根据 Handler 来，ActionController，ActiveRecord(ORM)，ActiveView(view).</p>
<p>然后对一个项目还有：配置，第三方库管理(bundler)，测试(RSpec/factory_girl)</p>
<p>这里要提一下Rspec，对于魔法语言 Ruby 来说，只有相对完善的测试(最好TDD)心里才踏实，推荐一本书《Everyday Rails Testing With RSpec》。</p>
<p>有时有些 Request 是好是操作，我们需要后台任务，需要了解 sidekiq.<br>对于 HTML 有时可能需要 Cache，这时简单粗暴的内存KV数据库 memcached。</p>
<p>有哪些地方容易写出坑：</p>
<ol>
<li>低效 SQL，所以对 SQL 也要有一定了解，知道一个链式 ActiveRecord 操作背后执行的哪条 SQL，而且对所用数据库(MySQL/Postgresql/MongoDB)有一定了解。</li>
<li>尽可能不要在 View 中写业务逻辑。</li>
<li>Controller 中有过多逻辑。</li>
<li>当我们把逻辑从 Controller 迁入 Model，Model 会迅速臃肿起来。</li>
</ol>
<p>对 Ruby 的理解需要达到什么程度？看懂《Ruby元编程》。</p>
<p>拓展阅读：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NDM0ODQwMw==&amp;mid=401924543&amp;idx=1&amp;sn=97de2e09c9fddfd905992c19aedb6182&amp;scene=1&amp;srcid=0730MmAb3a0bs0HtO0GyOAbP&amp;key=8dcebf9e179c9f3a0589ae28e0d6829d48d7e01e146408d73bc2fcd163de2bb20c17b7e5f8c582d1109f4adf2b0f4ea0&amp;ascene=0&amp;uin=MjA4NTM1NTg0Mw%3D%3D&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.11.1+build(15B42" target="_blank" rel="external">再谈 API 的撰写 - 架构-程序人生</a>&amp;version=11020201&amp;pass_ticket=EvQu1mLjNIQgfDQzipqPKaiaNiwUHzLpvnKsZoBfqUj7hTuQwuh6h1ek41Z%2FyBj7)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;后端(应用层)不同于前端，最重要的概念是 middleware/pipeline.&lt;/p&gt;
&lt;p&gt;Rails能较为深入的理解一定要建立在对后端整体架构理解架构的基础上，不然就会进入开始很爽越来越晕的尴尬节奏。&lt;/p&gt;
&lt;p&gt;大致分为两大部分：Server/App，一个负责接收分发 request，一个负责业务逻辑，他们之间的数据对接靠 Rack 规范。Server 具体可参考&lt;a href=&quot;http://insights.thoughtworkers.org/ruby-web-server/&quot;&gt;这篇文章&lt;/a&gt;。而 App 部分就是 Rails。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://focinfi.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Rails" scheme="http://focinfi.wang/tags/Rails/"/>
    
  </entry>
  
  <entry>
    <title>Golang Poller</title>
    <link href="http://focinfi.wang/2016/06/03/golang-poller/"/>
    <id>http://focinfi.wang/2016/06/03/golang-poller/</id>
    <published>2016-06-02T16:00:00.000Z</published>
    <updated>2017-03-18T13:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在通读 《The Go Programming Language》，真是好书。</p>
<p>读到 gorotuine，想到之前写 javascript 时常常需要一个 poller 轮询一些后台任务的执行结果，其实用 golang 的 gorutine 和 channel 实现可以更简洁而高效。</p>
<a id="more"></a>
<p>看代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Intervaler 是个接口用来让调用者自定义poller轮询时间间隔</span></div><div class="line"><span class="keyword">type</span> Intervaler <span class="keyword">interface</span> &#123;</div><div class="line">	Interval() time.Duration</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// IntervalerFunc 用来将 func() time.Duration 转化成 Intervaler</span></div><div class="line"><span class="keyword">type</span> IntervalerFunc <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span></div><div class="line"></div><div class="line"><span class="title">func</span> <span class="params">(intervalerFunc IntervalerFunc)</span> <span class="title">Interval</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span> &#123;</div><div class="line">	<span class="keyword">return</span> intervalerFunc()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Poller <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="comment">//要执行的方法</span></div><div class="line">	do           <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span></div><div class="line">    //用于调用者传递停止信号</div><div class="line">	<span class="title">cancle</span>       <span class="title">chan</span> <span class="title">int</span></div><div class="line">    //下次调用的时间间隔</div><div class="line">	<span class="title">nextInterval</span> <span class="title">Intervaler</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">// <span class="title">Poll</span> 轮询</div><div class="line"><span class="title">func</span> <span class="params">(poller *Poller)</span> <span class="title">Poll</span><span class="params">()</span> &#123;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		<span class="keyword">select</span> &#123;</div><div class="line">		<span class="keyword">case</span> &lt;-poller.cancle:</div><div class="line">			<span class="keyword">return</span></div><div class="line">		<span class="keyword">case</span> &lt;-time.After(poller.nextInterval.Interval()):</div><div class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">				<span class="keyword">if</span> err := poller.do(); err != <span class="literal">nil</span> &#123;</div><div class="line">					log.Errorf(<span class="string">"Poll poller.go: polling method returns a error: %v"</span>, err)</div><div class="line">					<span class="comment">// 或者结束整个轮询</span></div><div class="line">					<span class="comment">// poller.Cancel()</span></div><div class="line">				&#125;</div><div class="line">			&#125;()</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Cancel 向 cancel 发送信号</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(poller *Poller)</span> <span class="title">Cancel</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="built_in">println</span>(<span class="string">"Polling stopped"</span>)</div><div class="line">	poller.cancle &lt;- <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NewPoller 创建一个新的 Poller</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPoller</span><span class="params">(intervaler Intervaler, do <span class="keyword">func</span>()</span> <span class="title">error</span>) *<span class="title">Poller</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;Poller&#123;do: do, cancle: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), nextInterval: intervaler&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看看如何使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="comment">// 自定义 Intervaler</span></div><div class="line">    base := time.Second * <span class="number">0</span></div><div class="line">	interval := IntervalerFunc(<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Duration</span></span> &#123; </div><div class="line">      next := base</div><div class="line">      base += <span class="number">500</span> * time.Millisecond</div><div class="line">      <span class="keyword">return</span> next </div><div class="line">    &#125;)</div><div class="line"></div><div class="line">    <span class="comment">// 创建一个 poller</span></div><div class="line">	poller := NewPoller(interval,</div><div class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</div><div class="line">            <span class="comment">// 4秒后 输出 ping!</span></div><div class="line">			time.AfterFunc(time.Second*<span class="number">4</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="built_in">println</span>(<span class="string">"ping!"</span>) &#125;)</div><div class="line">			<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">		&#125;)</div><div class="line">    <span class="comment">// 5 秒后停止 polling</span></div><div class="line">	time.AfterFunc(time.Second*<span class="number">5</span>, poller.Cancel)</div><div class="line">    <span class="comment">// 开始 polling</span></div><div class="line">	poller.Poll()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ping!</div><div class="line">ping!</div><div class="line">Polling stopped</div></pre></td></tr></table></figure></p>
<p>差不多就是这么多了，大家可以根据不同的业务需求灵活自定义 Poller 的细节。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在通读 《The Go Programming Language》，真是好书。&lt;/p&gt;
&lt;p&gt;读到 gorotuine，想到之前写 javascript 时常常需要一个 poller 轮询一些后台任务的执行结果，其实用 golang 的 gorutine 和 channel 实现可以更简洁而高效。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://focinfi.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="golang" scheme="http://focinfi.wang/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>通过抄写学 golang</title>
    <link href="http://focinfi.wang/2016/05/31/learn-golang-from-copy/"/>
    <id>http://focinfi.wang/2016/05/31/learn-golang-from-copy/</id>
    <published>2016-05-31T05:00:22.000Z</published>
    <updated>2017-03-18T13:59:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>golang 专注于软件工程的实用性，学习起来不同于其他一些很 magic 的编程语言，我们要遵循标准和一些范式。</p>
<p>最好的资料就是 golang 的标准库源代码，只是有些库本身要处理的事情比较复杂，或者需要一定的知识储备，导致我们很难在短时间内理清脉络深入学习。那么我们需要一些小巧精悍适合初学者的开源库，我们可以按照这些标准找：</p>
<ol>
<li>符合 golang 标准，使用地道的编程范式。</li>
<li>完善文档和测试。</li>
<li>核心功能尽可能集中，代码规模尽可能的小。</li>
</ol>
<a id="more"></a>
<p>下面是我自己在寻觅的过程中感觉还不错的几个开源库：</p>
<h4 id="语法：gorilla-context"><a href="#语法：gorilla-context" class="headerlink" title="语法：gorilla/context"></a>语法：<a href="https://github.com/gorilla/context" target="_blank" rel="external">gorilla/context</a></h4><p>这个核心代码只有 100 行左右的小库，可以让我们学习到 golang 中 map 和 sync.RWMutex 在实践中的使用，更为重要的是，从中我们可以学习软件工程的一些优秀实践：注释，测试，命名等。</p>
<h4 id="HTTP：urfave-negroni"><a href="#HTTP：urfave-negroni" class="headerlink" title="HTTP：urfave/negroni"></a>HTTP：<a href="https://github.com/urfave/negroni" target="_blank" rel="external">urfave/negroni</a></h4><p>这个库核心代码也是 100 行左右，其功能就是为 <code>http.Handler</code> 添加 middleware 功能。这个库值得学习的地方在于理解 net/http 的设计理念，看看实践中如何用 interface 降低模块之间的耦合度以及如何设计模块和模块之间的关系。</p>
<h4 id="gorutine：go-playground-pool"><a href="#gorutine：go-playground-pool" class="headerlink" title="gorutine：go-playground/pool"></a>gorutine：<a href="https://github.com/go-playground/pool" target="_blank" rel="external">go-playground/pool</a></h4><p>核心代码 150 行，主要功能是实现了一个 gorutine 的 pool，抄写这个库的代码可以了解 golang 中 gorutine 的基本概念，channel 和 select 的使用方式以及如何用 sync.WaitGroup 管理 gorutine 。</p>
<p>实践抄写的过程中，可以带着这些问题：</p>
<ol>
<li>这个开源库的边界、对外接口或者叫核心功能是什么？</li>
<li>这个开源库在实现的过程中考虑了那些边界条件，如何把握效率与可用性之间的平衡点？</li>
<li>这个开源库用到了哪些内置库，如何使用的？</li>
<li>如果只看 README 和 go doc 输出的对外接口，能否在不了解内部实现的情况下自己写出来？</li>
<li>如果源码中有些东西我不熟悉，看过源码，理清思路后能否默写出来？</li>
<li>完成实现后，如何写出简单易读并且覆盖完善的测试？</li>
</ol>
<p>这是我之前练习 gorilla/context 写的文章，大家可以参考一下我当时的思路：<br><a href="http://www.jianshu.com/p/2e7ad8640c56" target="_blank" rel="external">Golang 学习 – “听写” gorilla/context</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang 专注于软件工程的实用性，学习起来不同于其他一些很 magic 的编程语言，我们要遵循标准和一些范式。&lt;/p&gt;
&lt;p&gt;最好的资料就是 golang 的标准库源代码，只是有些库本身要处理的事情比较复杂，或者需要一定的知识储备，导致我们很难在短时间内理清脉络深入学习。那么我们需要一些小巧精悍适合初学者的开源库，我们可以按照这些标准找：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;符合 golang 标准，使用地道的编程范式。&lt;/li&gt;
&lt;li&gt;完善文档和测试。&lt;/li&gt;
&lt;li&gt;核心功能尽可能集中，代码规模尽可能的小。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://focinfi.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="golang" scheme="http://focinfi.wang/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>以 Huffman coding 为例看 Golang 实用主义</title>
    <link href="http://focinfi.wang/2016/05/05/learn-golang-from-huffman/"/>
    <id>http://focinfi.wang/2016/05/05/learn-golang-from-huffman/</id>
    <published>2016-05-05T05:01:53.000Z</published>
    <updated>2017-03-18T13:59:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>不同编程即为不同解决问题的思路</p>
</blockquote>
<p>解决一个问题有很多思路，比如：</p>
<ol>
<li>过程式(C语言)：将解决问题的方式分解成若干步骤来控制数据</li>
<li>面向对象式 (Java/Ruby)：以对象为基本单位，定义其行为控制其内部状态，通过不同对象之间的协作解决问题</li>
<li>函数式(Lisp)：一切皆为函数，用连贯的思维方式定义过程，常用递归</li>
<li>组合式：将不同的解决方式组合起来，golang 经常会将面向对象与过称式组合起来</li>
</ol>
<a id="more"></a>
<h3 id="示例：-Huffman编码"><a href="#示例：-Huffman编码" class="headerlink" title="示例： Huffman编码"></a>示例： Huffman编码</h3><p>用 Golang 组合面向对象式和过程式：</p>
<p>首先我们应该确定整个 package (可视为一个大对象) 的输入和输出：</p>
<p>输入： <code>map[rune]int</code>, 其中 <code>rune</code> 是 golang 中的字符类型，也就是我们要进行编码的数据类型，<code>int</code> 是这个字符出现的次数</p>
<p>输出： <code>map[rune]string</code>, 其中 <code>string</code> 对应的01字符串编码结果。</p>
<h5 id="定义数据结构"><a href="#定义数据结构" class="headerlink" title="定义数据结构"></a>定义数据结构</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</div><div class="line">	Value      <span class="keyword">rune</span></div><div class="line">	Weight     <span class="keyword">int</span></div><div class="line">	LeftChild  *Node</div><div class="line">	RightChild *Node</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Nodes 用于 Node 以 weight 排序 </span></div><div class="line"><span class="keyword">type</span> Nodes []Node</div><div class="line"></div><div class="line"><span class="comment">// Tree 就是整棵Huffman树的根节点</span></div><div class="line"><span class="keyword">type</span> Tree <span class="keyword">struct</span> &#123;</div><div class="line">	Root *Node</div><div class="line">&#125;</div><div class="line"><span class="string">``</span><span class="string">` </span></div><div class="line"></div><div class="line">##### 定义 package 的对外接口</div><div class="line"></div><div class="line">`<span class="string">``</span><span class="keyword">go</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encode</span><span class="params">(priorityMap <span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span> <span class="title">map</span>[<span class="title">rune</span>]<span class="title">string</span></span> &#123;</div><div class="line">	stortedNodes := makeSortedNodes(priorityMap)</div><div class="line">	hfmTree := makeFuffManTree(stortedNodes)</div><div class="line">	<span class="keyword">return</span> hfmTree.encode()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="具体实现思路"><a href="#具体实现思路" class="headerlink" title="具体实现思路"></a>具体实现思路</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// makeSortedNodes 返回排好序的 []Node</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSortedNodes</span><span class="params">(priorityMap <span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">int</span>)</span> []<span class="title">Node</span></span> &#123;</div><div class="line">    <span class="comment">// 实现细节略</span></div><div class="line">	<span class="keyword">return</span> hfmNodes</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// makeFuffManTree 将排好序的 Nodes 构造成Huffman树，</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeFuffManTree</span><span class="params">(nodes Nodes)</span> *<span class="title">Tree</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nodes) &lt; <span class="number">2</span> &#123;</div><div class="line">		<span class="built_in">panic</span>(<span class="string">"Must contain 2 or more emlments"</span>)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//实现细节略</span></div><div class="line">	<span class="keyword">return</span> hfmTree</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// encode 以 tree 根节点开始遍历，得到最终编码</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree Tree)</span> <span class="title">encode</span><span class="params">()</span> <span class="title">map</span>[<span class="title">rune</span>]<span class="title">string</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> initialCode <span class="keyword">string</span></div><div class="line">	encodeMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">rune</span>]<span class="keyword">string</span>)</div><div class="line">	tree.Root.traverse(initialCode, <span class="function"><span class="keyword">func</span><span class="params">(value <span class="keyword">rune</span>, code <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">		encodeMap[value] = code</div><div class="line">	&#125;)</div><div class="line">	<span class="keyword">return</span> encodeMap</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// traverse 从当前节点开始向下遍历，使用递归方式</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n Node)</span> <span class="title">traverse</span><span class="params">(code <span class="keyword">string</span>, visit <span class="keyword">func</span>(<span class="keyword">rune</span>, <span class="keyword">string</span>)</span>)</span> &#123;</div><div class="line">	<span class="keyword">if</span> leftNode := n.LeftChild; leftNode != <span class="literal">nil</span> &#123;</div><div class="line">		leftNode.traverse(code+<span class="string">"0"</span>, visit)</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		visit(n.Value, code)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	n.RightChild.traverse(code+<span class="string">"1"</span>, visit)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的实现方式上可以看到，既有面向对象的 Node 和 Tree 也有过程式的 <code>makeSortedNodes</code> 和 <code>makeFuffManTree</code> 还有 <code>func (n Node) traverse(code string, visit func(rune, string))</code> 的递归调用，高阶函数参数等。所以 golang 更加注重实用性。</p>
<p>这里仅仅从实现的角度定义了 Huffman编码 的对外接口，其实还不够通用和高效，参考 golang 的 <code>io</code> package 我们可以将 Encode 做成 <code>Encode(v []byte, w io.Writer) (int, error)</code> 这样就可以直接接入标准输入输出的package了，当然这里要做一些内部实现的调整。如果想要健壮和高效，还可以结合 buffer 实现缓冲。</p>
<p>项目完整代码请进：<a href="https://github.com/focinfi/ghuffmancoding" target="_blank" rel="external">github</a></p>
<p>相关阅读：<a href="http://www.jianshu.com/p/baf3bb7d430d" target="_blank" rel="external">以 Huffman coding 为例看函数式编程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不同编程即为不同解决问题的思路&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决一个问题有很多思路，比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;过程式(C语言)：将解决问题的方式分解成若干步骤来控制数据&lt;/li&gt;
&lt;li&gt;面向对象式 (Java/Ruby)：以对象为基本单位，定义其行为控制其内部状态，通过不同对象之间的协作解决问题&lt;/li&gt;
&lt;li&gt;函数式(Lisp)：一切皆为函数，用连贯的思维方式定义过程，常用递归&lt;/li&gt;
&lt;li&gt;组合式：将不同的解决方式组合起来，golang 经常会将面向对象与过称式组合起来&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://focinfi.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="golang" scheme="http://focinfi.wang/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>以 Huffman coding 为例看函数式编程</title>
    <link href="http://focinfi.wang/2016/05/02/learn-functional-programming-from-huffman/"/>
    <id>http://focinfi.wang/2016/05/02/learn-functional-programming-from-huffman/</id>
    <published>2016-05-02T05:04:13.000Z</published>
    <updated>2017-03-18T13:59:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>不同编程即为不同解决问题的思路</p>
</blockquote>
<p>解决一个问题有很多思路，比如：</p>
<ol>
<li>过程式(C语言)：将解决问题的方式分解成若干步骤来控制数据。</li>
<li>面向对象式 (Java/Ruby)：以对象为基本单位，定义其行为控制其内部状态，通过不同对象之间的协作解决问题。</li>
<li>函数式(Lisp)：一切皆为函数，用连贯的思维方式定义过程，常用递归。</li>
<li>组合式：将不同的解决方式组合起来，golang 经常会将面向对象与过程式组合起来。</li>
</ol>
<a id="more"></a>
<h4 id="示例：-Huffman编码"><a href="#示例：-Huffman编码" class="headerlink" title="示例： Huffman编码"></a>示例： Huffman编码</h4><p>用 Lisp 的一个方言 Scheme 来实现：</p>
<p>输入 <code>&#39;((A 1) (B 3) (C 2))</code>, A B C 为带编码字符，1 2 3 为出现次数。<br>输出 <code>&#39;((b 0) (a 0 1) c 1 1)</code></p>
<h4 id="定义叶子节点"><a href="#定义叶子节点" class="headerlink" title="定义叶子节点"></a>定义叶子节点</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-leaf</span> symbol weight)</div><div class="line">  (<span class="name">list</span> 'leaf symbol weight))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">leaf</span>? object)</div><div class="line">  (<span class="name">eq</span>? (<span class="name">car</span> object) 'leaf))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">symbol-leaf</span> object)</div><div class="line">  (<span class="name">cadr</span> object))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">weight-leaf</span> object)</div><div class="line">  (<span class="name">caddr</span> object))</div></pre></td></tr></table></figure>
<p>如果没有接触过 lisp 的同学可能对上面的表示方式有点陌生，其实就是用括号代表方法调用，括号里的第一个位置是方法名称，后面的是调用该方法的参数。</p>
<p>上面的几行代码定义了叶子节点 leaf 及相关函数。</p>
<h4 id="定义树节点"><a href="#定义树节点" class="headerlink" title="定义树节点"></a>定义树节点</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-code-tree</span> left right)</div><div class="line">  (<span class="name">list</span> </div><div class="line">    left</div><div class="line">    right</div><div class="line">    (<span class="name">append</span> (<span class="name">symbols</span> left) (<span class="name">symbols</span> right))</div><div class="line">    (<span class="name">+</span> (<span class="name">weight</span> left) (<span class="name">weight</span> right))))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">left-branch</span> tree) (<span class="name">car</span> tree))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">right-branch</span> tree) (<span class="name">cadr</span> tree))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">symbols</span> tree)</div><div class="line">  (<span class="name">if</span> (<span class="name">leaf</span>? tree)</div><div class="line">    (<span class="name">list</span> (<span class="name">symbol-leaf</span> tree))</div><div class="line">    (<span class="name">caddr</span> tree)))</div><div class="line"></div><div class="line">(<span class="name">define</span> (<span class="name">weight</span> tree)</div><div class="line">  (<span class="name">if</span> (<span class="name">leaf</span>? tree)</div><div class="line">    (<span class="name">weight-leaf</span> tree)</div><div class="line">    (<span class="name">cadddr</span> tree)))</div></pre></td></tr></table></figure>
<p>同样的道理，定义了用于在构造 Huffman 树中非叶子的节点 tree 及其相关取值函数。</p>
<h4 id="有序-list-构造方法"><a href="#有序-list-构造方法" class="headerlink" title="有序 list 构造方法"></a>有序 list 构造方法</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">adjoin-set</span> x set)</div><div class="line">  <span class="comment">;如果 set 为空，则返回以 x 作为唯一元素的 list</span></div><div class="line">  (<span class="name">cond</span> ((<span class="name">null</span>? set) </div><div class="line">      (<span class="name">list</span> x)) </div><div class="line">    <span class="comment">;如果 set 的第一个元素的 weight 大于 x 的 weight，则将 x 和 set 组合成一个新的 list 返回</span></div><div class="line">    ((<span class="name">&gt;</span> (<span class="name">weight</span> (<span class="name">car</span> set)) (<span class="name">weight</span> x))</div><div class="line">      (<span class="name">cons</span> x set)) </div><div class="line">    <span class="comment">; 否则将 set 的以第一个只取出，让后递归调用 `adjoin-set`</span></div><div class="line">    (<span class="name">else</span> (<span class="name">cons</span> (<span class="name">car</span> set) (<span class="name">adjoin-set</span> x (<span class="name">cdr</span> set)))))) </div><div class="line">(<span class="name">define</span> (<span class="name">make-leaf-set</span> pairs)</div><div class="line">  (<span class="name">if</span> (<span class="name">null</span>? pairs)</div><div class="line">    '()</div><div class="line">    (<span class="name">let</span> ((<span class="name">pair</span> (<span class="name">car</span> pairs)))</div><div class="line">      (<span class="name">adjoin-set</span> (<span class="name">make-leaf</span> (<span class="name">car</span> pair) (<span class="name">cadr</span> pair))</div><div class="line">        (<span class="name">make-leaf-set</span> (<span class="name">cdr</span> pairs))))))</div></pre></td></tr></table></figure>
<p> <code>adjoin-set</code> 的功能就是 x 插入到有序 list set 中，保证插入后的 list 仍然有序。lisp 中的 <code>cond</code> 可理解为 其他语言中的 <code>switch</code>，而 <code>cons</code> 可理解为将两个元素结合成一个 list。 乍一看这个所谓“插入”元素的方法有点奇怪，而且没有用任何<strong>临时变量</strong>。其思路将整个插入的过程用递归调用的方式表示： 用过程（函数）代替了临时变量。举了例子：<code>(adjoin-set 3 &#39;(1 2))</code>，执行顺序是：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">cons</span> <span class="number">1</span> (<span class="name">adjoin-set</span> <span class="number">3</span> '(<span class="number">2</span>)))</div><div class="line">(<span class="name">cons</span> <span class="number">1</span> (<span class="name">cons</span> <span class="number">2</span> (<span class="name">adjoin-set</span> <span class="number">3</span> '())))</div><div class="line">(<span class="name">cons</span> <span class="number">1</span> (<span class="name">cons</span> <span class="number">2</span> (<span class="name">cons</span> <span class="number">3</span> '())))</div><div class="line">(<span class="name">cons</span> <span class="number">1</span> (<span class="name">cons</span> <span class="number">2</span> '(<span class="number">3</span>)))</div><div class="line">(<span class="name">cons</span> <span class="number">1</span> '(<span class="number">2</span> <span class="number">3</span>))</div><div class="line">'(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>可以看到在执行序列中，推迟 <code>cons</code> 的执行，用参数求值压栈从而省去了临时变量。在  <code>make-leaf-set</code> 中思路也一样：不断地从 paris 中取元素，交给 <code>adjoin-set</code> 插入到 list 中。整个编写过程中基本上用程序流畅地表达了我们的解题思路。</p>
<h4 id="Huffman树构造方法"><a href="#Huffman树构造方法" class="headerlink" title="Huffman树构造方法"></a>Huffman树构造方法</h4><p>在插入元素这种简单的问题中函数式威力还远远没有体现出来，请看下面构造 Huffman树 的函数实现：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">make-tree</span> leaves)</div><div class="line">  (<span class="name">cond</span> ((<span class="name">or</span> (<span class="name">null</span>? (<span class="name">car</span> leaves)) (<span class="name">null</span>? (<span class="name">cadr</span> leaves)))</div><div class="line">      (<span class="name">error</span> <span class="string">"leaves is not enough"</span>))</div><div class="line">    ((<span class="name">null</span>? (<span class="name">cddr</span> leaves))</div><div class="line">      (<span class="name">make-code-tree</span> (<span class="name">car</span> leaves) (<span class="name">cadr</span> leaves)))</div><div class="line">    (<span class="name">else</span> (<span class="name">make-tree</span> (<span class="name">adjoin-set</span> (<span class="name">make-code-tree</span> (<span class="name">car</span> leaves) (<span class="name">cadr</span> leaves)) (<span class="name">cddr</span> leaves))))))</div></pre></td></tr></table></figure>
<p>几行代码就将构造 Huffman树 的核心逻辑表达清楚了：将按 weight 升序 leaves 的前两个拿出来做成一个 tree node，<code>adjoin-set</code> 到剩下的 leaves 中，然后不断重复这个操作，直到 leaves 中只剩下两个元素，将这两个元素最为 最终 Huffman树 的左右子树，然后返回。怎么样？一气呵成。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>对 Huffman树 遍历编码的实现也是精炼得有种思维的美感：<br>先进行左子树遍历，直到找到叶子节点，构造成结果 list 中一个元素，然后回到上一层递归，进入右子树，不断重复直到遍历完所有节点。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(<span class="name">define</span> (<span class="name">encode</span> tree)</div><div class="line">  (<span class="name">define</span> (<span class="name">visit</span> n bits)</div><div class="line">    (<span class="name">if</span> (<span class="name">leaf</span>? n)</div><div class="line">      <span class="comment">; 找到了一个叶子节点</span></div><div class="line">      (<span class="name">cons</span> (<span class="name">symbol-leaf</span> n) bits)</div><div class="line">      <span class="comment">; 用 cons 对 visit 的递归调用</span></div><div class="line">      (<span class="name">cons</span> (<span class="name">visit</span> (<span class="name">left-branch</span> n) (<span class="name">cons</span> <span class="number">0</span> bits))</div><div class="line">        (<span class="name">visit</span> (<span class="name">right-branch</span> n) (<span class="name">cons</span> <span class="number">1</span> bits)))))</div><div class="line">  (<span class="name">visit</span> tree '()))</div><div class="line"></div><div class="line"><span class="comment">;测试</span></div><div class="line">(<span class="name">define</span> leaf-set (<span class="name">make-leaf-set</span> '((A <span class="number">1</span>) (B <span class="number">3</span>) (C <span class="number">2</span>))))</div><div class="line">(<span class="name">define</span> tree (<span class="name">make-tree</span> leaf-set))</div><div class="line">(<span class="name">encode</span> tree) <span class="comment">; outputs: ((b 0) (a 0 1) c 1 1)</span></div></pre></td></tr></table></figure>
<p>详细代码请进 <a href="https://github.com/Focinfi/scheme-practices/blob/master/haffman.scm" target="_blank" rel="external">github</a></p>
<p>ps: 本篇用到部分《计算机程序的构造与解析》代码。强烈建议大家学习 MIT 的这门公开课。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;不同编程即为不同解决问题的思路&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决一个问题有很多思路，比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;过程式(C语言)：将解决问题的方式分解成若干步骤来控制数据。&lt;/li&gt;
&lt;li&gt;面向对象式 (Java/Ruby)：以对象为基本单位，定义其行为控制其内部状态，通过不同对象之间的协作解决问题。&lt;/li&gt;
&lt;li&gt;函数式(Lisp)：一切皆为函数，用连贯的思维方式定义过程，常用递归。&lt;/li&gt;
&lt;li&gt;组合式：将不同的解决方式组合起来，golang 经常会将面向对象与过程式组合起来。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="j技术" scheme="http://focinfi.wang/categories/j%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="scheme" scheme="http://focinfi.wang/tags/scheme/"/>
    
  </entry>
  
  <entry>
    <title>前端入门学习资料推荐</title>
    <link href="http://focinfi.wang/2016/03/23/material-for-front-end-beginner/"/>
    <id>http://focinfi.wang/2016/03/23/material-for-front-end-beginner/</id>
    <published>2016-03-23T05:11:52.000Z</published>
    <updated>2017-03-18T13:59:27.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本功"><a href="#基本功" class="headerlink" title="基本功"></a>基本功</h3><ol>
<li>英语，查看资料尽量看英文</li>
<li>C语言，数据结构，计算机网络(HTTP)</li>
<li>学会利用 Google，有编程问题去 stackoverflow.com 上找答案</li>
<li>了解 git，学会使用 github.com</li>
</ol>
<a id="more"></a>
<h3 id="书籍资料"><a href="#书籍资料" class="headerlink" title="书籍资料"></a>书籍资料</h3><ol>
<li><p><a href="http://book.douban.com/subject/25752357/" target="_blank" rel="external">《Head first HTML CSS》</a></p>
</li>
<li><p><a href="http://book.douban.com/subject/1236999/" target="_blank" rel="external">《The C Programming Language》</a></p>
</li>
<li><p><a href="http://book.douban.com/subject/6424904/" target="_blank" rel="external">《大话数据结构》</a></p>
</li>
<li><p><a href="http://book.douban.com/subject/25863515/" target="_blank" rel="external">《图解HTTP》</a></p>
</li>
<li><p><a href="http://book.douban.com/subject/3590768/" target="_blank" rel="external">《JavaScript语言精粹》</a></p>
</li>
<li><p><a href="http://book.douban.com/subject/10549733/" target="_blank" rel="external">《JavaScript权威指南》</a>（可作字典使用）</p>
</li>
</ol>
<h3 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h3><ol>
<li><p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰git教程</a></p>
</li>
<li><p><a href="http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000" target="_blank" rel="external">廖雪峰 JavaScript 教程</a></p>
</li>
<li><p><a href="https://github.com/unruledboy/WebFrontEndStack" target="_blank" rel="external">unruledboy/WebFrontEndStack
</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/20824615" target="_blank" rel="external">如何优雅地使用 Stack Overflow？</a></p>
</li>
<li><p><a href="http://blog.csdn.net/wuhenliushui/article/details/20038819/" target="_blank" rel="external">当你在浏览器地址栏输入一个URL后回车，将会发生的事情？</a>（不必深究每一个细节，但要有整体概念）</p>
</li>
</ol>
<h3 id="视频推荐"><a href="#视频推荐" class="headerlink" title="视频推荐"></a>视频推荐</h3><p><a href="http://www.imooc.com/course/programdetail/pid/32" target="_blank" rel="external">慕课网 <strong>Web前端工程师</strong> 学习计划</a><br>（非常系统，如果看不下去书可以尝试看视频教程）</p>
<h3 id="在线学习"><a href="#在线学习" class="headerlink" title="在线学习"></a>在线学习</h3><ol>
<li><a href="https://www.codecademy.com" target="_blank" rel="external">https://www.codecademy.com</a> </li>
<li>实验楼 <a href="https://www.shiyanlou.com" target="_blank" rel="external">https://www.shiyanlou.com</a></li>
</ol>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><ol>
<li><p>如何保持持续的热情？</p>
<ol>
<li>知识引导实践，争取在最短的时间内将学习到的东西写成能跑起来的代码，保证 <strong>持续的正面反馈</strong>。</li>
<li>实践反补对知识的理解，举一反三。</li>
<li>螺旋式学习节奏。</li>
</ol>
</li>
<li><p>时间很紧张怎么办？</p>
<ol>
<li>从上到下的学习思路，从问题出发，或者说是从项目出发，需要什么就去学，不懂的就去问，快速实现最终目标。</li>
<li><strong>但请不要忘记，建立自己的知识体系</strong>。</li>
</ol>
</li>
<li><p>编程水平提升思路：</p>
<ol>
<li><p>中国有句古话：<strong>文章三分写七分改</strong>。编程也是如此，复制粘贴只能作万里长征第一步，千万不可以为革命就此胜利。第一个项目不论大小，务必做到极致，每一个细节都力求做到最好，可以向书籍上的示例代码学习，可以向开源项目学习，可以请前辈 review。</p>
</li>
<li><p>Do it, Do it right, Do it better.</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>May the force be with you.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;基本功&quot;&gt;&lt;a href=&quot;#基本功&quot; class=&quot;headerlink&quot; title=&quot;基本功&quot;&gt;&lt;/a&gt;基本功&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;英语，查看资料尽量看英文&lt;/li&gt;
&lt;li&gt;C语言，数据结构，计算机网络(HTTP)&lt;/li&gt;
&lt;li&gt;学会利用 Google，有编程问题去 stackoverflow.com 上找答案&lt;/li&gt;
&lt;li&gt;了解 git，学会使用 github.com&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://focinfi.wang/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://focinfi.wang/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
